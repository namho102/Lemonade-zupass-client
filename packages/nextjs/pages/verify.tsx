import { useRouter } from "next/router";
import { EdDSATicketPCDPackage } from "../pcd/eddsa-ticket-pcd/src";
import { ZKEdDSAEventTicketPCDArgs, ZKEdDSAEventTicketPCDPackage } from "../pcd/zk-eddsa-event-ticket-pcd/src";
import { ArgumentTypeName } from "@pcd/pcd-types";
import { SemaphoreIdentityPCDPackage } from "@pcd/semaphore-identity-pcd";
import { NextPage } from "next";
import { v5 as uuidv5 } from "uuid";
// import { mainnet } from "wagmi";
import { constructZupassPcdGetRequestUrl, isLemonadePublicKey } from "~~/utils";
import { notification } from "~~/utils/scaffold-eth";

const uuidNamespace = "5ea7f241-94a2-4099-b986-bab20fc8443d";
// const ticketName = "Holder";
// const nftProductId = uuidv5(ticketName, uuidNamespace);
const lemonadeEventId = "654e34279c2dd8ebfdb56f59";
const lemonadeTicketTypeId = "654e343d9c2dd8ebfdb56f71";
// const lemondaeEventName = "Lemonade";
const ticketEventId = uuidv5(lemonadeEventId, uuidNamespace);
// const nftEventId = uuidv5(mainnet.id.toString() + "0xE42caD6fC883877A76A26A16ed92444ab177E306", uuidNamespace);
// const nftEventId = uuidv5(params.chainId + params.contract, uuidNamespace);

const ticketProductId = uuidv5(lemonadeTicketTypeId, uuidNamespace);

const args: ZKEdDSAEventTicketPCDArgs = {
  ticket: {
    argumentType: ArgumentTypeName.PCD,
    pcdType: EdDSATicketPCDPackage.name,
    value: undefined,
    userProvided: true,
    validatorParams: {
      eventIds: [ticketEventId],
      productIds: [ticketProductId],
      notFoundMessage: "No eligible PCDs found",
    },
  },
  identity: {
    argumentType: ArgumentTypeName.PCD,
    pcdType: SemaphoreIdentityPCDPackage.name,
    value: undefined,
    userProvided: true,
  },
  validEventIds: {
    argumentType: ArgumentTypeName.StringArray,
    value: [ticketEventId],
    userProvided: false,
  },
  externalNullifier: {
    argumentType: ArgumentTypeName.BigInt,
    value: undefined,
    userProvided: false,
  },
  fieldsToReveal: {
    argumentType: ArgumentTypeName.ToggleList,
    value: {},
    userProvided: false,
    hideIcon: true,
  },
  watermark: {
    argumentType: ArgumentTypeName.BigInt,
    value: "1",
    userProvided: false,
  },
};

const Verify: NextPage = () => {
  const { query } = useRouter();
  const proof = query && query.proof && JSON.parse(decodeURIComponent(query.proof as string));
  return (
    <div className="flex items-center flex-col p-10 space-y-8">
      <div className="bg-base-100 flex items-center flex-col p-5 rounded-2xl">
        <div className="px-5 text-white">
          <h1 className="text-center mb-4">
            <span className="block text-2xl mb-2">Welcome to</span>
            <span className="block text-4xl font-bold">Lemonade ZuPass NFT Verification</span>
          </h1>
        </div>
        {!proof ? (
          <button
            className="btn btn-outline mt-4"
            onClick={() => {
              const result = constructZupassPcdGetRequestUrl(
                "https://zupass.org",
                `${window.location.href}`,
                ZKEdDSAEventTicketPCDPackage.name,
                args,
              );

              window.location.href = result; //or you could have a pop up but it's more complicated
            }}
          >
            Get Proof
          </button>
        ) : (
          <button
            className="btn btn-outline mt-4"
            onClick={async () => {
              if (!proof) {
                notification.error("No PCD found!");
                return;
              }

              const deserializedPCD = await ZKEdDSAEventTicketPCDPackage.deserialize(proof.pcd);

              if (!ZKEdDSAEventTicketPCDPackage.verify(deserializedPCD)) {
                notification.error(`[ERROR Frontend] ZK ticket PCD is not valid`);
                return;
              }
              console.log("deserializedPCD", deserializedPCD);

              if (!isLemonadePublicKey(deserializedPCD.claim.signer)) {
                notification.error(`[ERROR Frontend] PCD is not signed by Zupass`);
                return;
              }

              // TODO: Use real nonce generated by the server
              if (deserializedPCD.claim.watermark.toString() !== "1") {
                notification.error(`[ERROR Frontend] PCD watermark doesn't match`);
                return;
              }

              notification.success(
                <>
                  <p className="font-bold m-0">Frontend Verified!</p>
                  <p className="m-0">
                    The proof has been verified
                    <br /> by the frontend.
                  </p>
                </>,
              );
            }}
          >
            Verify
          </button>
        )}
      </div>
    </div>
  );
};

export default Verify;
